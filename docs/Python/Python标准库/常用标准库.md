# 常用标准库

## itertool 工具

`itertools` 是 python 标准库，里面有许多高级函数，比如 笛卡尔积 `itertools.product` 等。

```python
import itertools

# chain 用来碾平列表
# chain 默认返回一个可迭代对象，使用 list() 函数可以转换为列表
lis = [('A','a'), ('B','b'), ('C','c')]
list(itertools.chain(*lis))
[out:]
['A', 'a', 'B', 'b', 'C', 'c']

# product 笛卡尔积
# product 默认返回一个可迭代对象，使用 list() 函数可以转换为列表
city_code = [("北京", "54511"), ("重庆", "57516")]
prng = [[2011, 1], [2011, 2]]
[list(itertools.chain(*x)) for x in itertools.product(city_code, prng)]
[out:]
[['北京', '54511', 2011, 1], ['北京', '54511', 2011, 2], ['重庆', '57516', 2011, 1], ['重庆', '57516', 2011, 2]]

# zip() 将会在任意一个输入迭代器被遍历完时停止。
# 如果想完整的遍历所有的输入迭代器（即使它们有不同的长度），我们可以用 zip_longest() 函数。
```

itertools 下有 2 个比较难理解，但是超级有用的函数 chain、product。

```python
import itertools
a = [("北京", "54511"), ("重庆", "57516")]
b = [[2011, 1], [2011, 2]]
c = list(zip(a, b))
d = list(itertools.product(a, b))
e = [list(itertools.chain(*x)) for x in c]
f = [list(itertools.chain(*x)) for x in d]
print(f'变量 a：{a}\n变量 b：{b}\n变量 c：{c}\n变量 d：{d}\n变量 e：{e}\n变量 f：{f}')
[输出：]
变量a：[('北京', '54511'), ('重庆', '57516')]
变量b：[[2011, 1], [2011, 2]]
变量c：[(('北京', '54511'), [2011, 1]), (('重庆', '57516'), [2011, 2])]
变量d：[(('北京', '54511'), [2011, 1]), (('北京', '54511'), [2011, 2]), (('重庆', '57516'), [2011, 1]), (('重庆', '57516'), [2011, 2])]
变量e：[['北京', '54511', 2011, 1], ['重庆', '57516', 2011, 2]]
变量f：[['北京', '54511', 2011, 1], ['北京', '54511', 2011, 2], ['重庆', '57516', 2011, 1], ['重庆', '57516', 2011, 2]]
```

理解：

> chain：碾平多个列表。列表的 extend 方法可以在列表末尾一次性追加另一个序列中的多个值，而 chain 函数相当于 extend 方法的升级版，把多个列表链式连接起来。`chain()` 函数将几个迭代器作为参数，并返回一个迭代器。这个迭代器将会依次遍历那些作为输入的迭代器。
>
> 内置函数 `zip()` 返回一个迭代器，这个迭代器将同时遍历多个输入迭代器，并返回一个由在这些迭代器中得到的元素所组合成的元祖。
>
> product：`product()` 常用来取代对多个序列的嵌套 `for` 循环，返回一个包含所有输入组合的笛卡儿积的迭代器。

## queue 线程安全的 FIFO 队列

queue 模块提供了一个适用于多线程编程的先进先出（FIFO）数据结构。它可以用来安全地在生产者和消费者线程之间传递消息或其他数据。锁是调用者来处理的，所有多个线程能够安全且容易的使用同样的 Queue 实例工作。Queue 的大小（它包含的元素的数量）可能会受到限制，以调节内存的适用或处理。

`deque` --- 线程安全的高效双向队列

## 邮件

官方示例：<https://docs.python.org/zh-cn/3/library/email.examples.html>

参考：<https://blog.csdn.net/cxm_hwj/article/details/6690069>

<https://blog.csdn.net/weixin_37958284/article/details/77186279>

* 如果在邮件中要添加附件，必须定义 multipart/mixed 段；

* 如果存在内嵌资源，至少要定义 multipart/related 段；

* 如果纯文本与超文本共存，至少要定义 multipart/alternative 段。

什么是“至少”？举个例子说，如果只有纯文本与超文本正文，那么在邮件头中将类型扩大化，定义为 multipart/related，甚至 multipart/mixed，都是允许的。

multipart 诸类型的共同特征是，在段头指定“boundary”参数字符串，段体内的每个子段以此串定界。所有的子段都以“--”+boundary 行开始，父段则以“--”+boundary+“--”行结束。段与段之间也以空行分隔。

```python
+------------------------- multipart/mixed ----------------------------+
|                                                                      |
|  +----------------- multipart/related ------------------+            |
|  |                                                      |            |
|  |  +----- multipart/alternative ------+  +----------+  |  +------+  |
|  |  |                                  |  |  内嵌资源 |  |  |  附件 |  |
|  |  |  +------------+  +------------+  |  +----------+  |  +------+  |
|  |  |  | 纯文本正文  |   |  超文本正文 |  |                |            |
|  |  |  +------------+  +------------+  |  +----------+  |  +------+  |
|  |  |                                  |  |  内嵌资源 |  |  |  附件 |  |
|  |  +----------------------------------+  +----------+  |  +------+  |
|  |                                                      |            |
|  +------------------------------------------------------+            |
|                                                                      |
+----------------------------------------------------------------------+
```

例 1 只有纯文本正文，实际上属于 multipart 层次关系图中的一个特殊情况。如果非要避简就繁，写成下面的形式，也是完全符合 MIME 精神的。

```python
Date: Thu, 18 Apr 2002 09:32:45 +0800
From: <bhw98@sina.com>
To: <bhwang@jlonline.com>
Subject: Test
Mime-Version: 1.0
Content-Type: multipart/alternative; boundary="{[(^_^)]}"

--{[(^_^)]}
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: 7bit

This is a simple mail.

--{[(^_^)]}--
```

<https://docs.python.org/zh-cn/3/library/email.message.html>

EmailMessage.set_content() 方法

```python
EmailMessage.set_content(msg, subtype="plain", charset='utf-8' cte=None, disposition=None, filename=None, cid=None, params=None, headers=None)
# cte:quoted-printable, base64, 7bit, 8bit, and binary
```

## os 文件操作

1. `os.listdir()`获取的只是指定路径下所有文件名组成的字符串列表，`os.scandir()`这可以返回一个生成器，每个元素是`DirEntry`对象，保留了文件相关的信息
2. `os.remove()`只能删除文件，`os.rmdir()`只能删除空目录，`shutil.rmtree()`可以递归删除目录

`os.listdir()` 返回的是一个包含目录下所有目录和文件 name 的 无序列表 list。

`os.listdir().sort()` 用 sort 方法进行。

`os.scandir()` 返回的是目录下所有对象的有序的 生成器。根据官方文档，此方法速度最快，而且返回更多信息，而且返回的是惰性的生成器，后面凡是需要迭代操作的，应该优先使用。

## JSON 格式

json 文件的读写

```python
# json 文件读取
r_text = Path(r"1.json").read_text(encoding='utf8')
r_json = json.loads(r_text)

# 写入 json 文件
data = r_json.get('inData')
data_json = json.dumps(data, sort_keys=, indent=4, separators=(',', ':'), ensure_ascii=False)
Path('2.json').write_text(data_json,)
```

Performs the following translations in decoding by default:

| JSON          | Python |
| ------------- | ------ |
| object        | dict   |
| array         | list   |
| string        | str    |
| number (int)  | int    |
| number (real) | float  |
| true          | True   |
| false         | False  |
| null          | None   |

## ConfigParser 解析配置文件

**注意：**使用 `.write()` 方法写入文件，会导致备注行丢失。

参考：<https://www.cnblogs.com/feeland/p/4514771.html>

配置文件格式：

```ini
; 配置文件，";" 或 "#" 表示注释。
; 编码：UTF-8

[section]
name=value
;或者
name: value
;"#" 和";" 表示注释

[DEFAULT] #设置默认的变量值，初始化

;%(dir)s 会被frob代替。默认值会以字典的形式传递给ConfigParser的构造器。section一般存放的哦内置目录下，如果切换到其他的目录需啊哟指定存放位置。
[My Section]
foodir: %(dir)s/whatever
dir=frob
long: this value continues
   in the next line
```

使用方法：

```python
import configparser
config = configparser.ConfigParser()
config.read('host.cfg', encoding='utf-8')
my_pass = config.get('host', 'pass')
```

加密存储密码：

```python
# 导入密码加密模块
import hashlib

p = b'123456'  # 要加密的数据

password = hashlib.sha256(passwordstr).hexdigest() # 3.获取加密结果

pwd = h.hexdigest()  # 解密
```

## 压缩文件

使用 shutil 模块就可以实现创建 zip、tar、bztar、gztar、xztar 格式的压缩文件

```python
import shutil
shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])
```

* `base_name`：压缩后的文件名。如果不指定绝对路径，则压缩文件保存在当前目录下。这个参数必须指定。
* `format`：压缩格式，可以是“zip”, “tar”, “bztar” ，“gztar”，“xztar”中的一种。这个参数也必须指定。
* `root_dir`：设置压缩包里的根目录，一般使用默认值，不特别指定。
* `base_dir`：要进行压缩的源文件或目录。
* `owner`：用户，默认当前用户。
* `group`：组，默认当前组。
* `logger`：用于记录日志，通常是`logging.Logger`对象。

实例：

```python
import shutil

# 压缩后的文件名不用带后缀，他会自动带上后缀名
shutil.make_archive(r"e:\3", "zip",  base_dir=r'e:\dcim')
```

解压缩：

```python
shutil.unpack_archive(filename[, extract_dir[, format]])
```

解压缩或解包源文件。

* filename 是压缩文档的完整路径
* extract_dir 是解压缩路径，默认为当前目录。
* format 是压缩格式。默认使用文件后缀名代码的压缩格式。

范例：

```python
import shutil
shutil.unpack_archive("d:\\3.zip", "f:\\3", 'zip')
```

shutil 模块的压缩和解压功能，在后台是通过调用 zipfile 和 tarfile 两个模块来进行的。

## contextlib 上下文管理器

1. 使用`contextlib`标准库可以快速构造上下文管理器
2. 使用`contextlib`库中的`contextmanager`装饰器装饰一个返回生成器的函数，就构造了一个上下文管理器，其中`yield`前面的内容是`with`表达式执行之前的操作，`yield`之后的内容是`with`表达式执行之后的操作，`yield`如果有返回的内容，则会返回给`with`表达式中`as`之后的变量

## csv 模块

参考官方文档：<https://docs.python.org/zh-cn/3/library/csv.html>

<https://realpython.com/python-csv/>

标准的写法：

```python
import csv
with open('passwd', newline='') as f:
    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)
    for row in reader:
        print(row)
```

Path 库的写法：

```python
with Path(csv_path).open(encoding='gb18030') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=',', quotechar='|')
    res = [x for x in spamreader if x[2]]
```

## 简单的服务器

警告：不推荐在生产环境中使用`http.server`。它只实现了基本的安全检查功能。

```sh
python -m http.server 8000
# 参数 -d/--directory 指定目录
python -m http.server -d /tmp/
```
