# pandas 表格处理

参考：[用 Python 完成 Excel 的常用操作](https://www.jianshu.com/p/9bc9f473dd22)

pandas 系列学习（六）：数据聚合 <https://blog.csdn.net/CoderPai/article/details/83577805>

## 分列

参考：<https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.split.html>

```python
# 分列，默认 pat 字符数大于 1 则支持正则表达式。
# Series.str.split(pat=None, n=- 1, expand=False)
df['label'].str.split('\.|_', expand=True)
```

## 合列

```python
# 不推荐使用此方法
# 注：但是某一列如果为空，另一列不为空，则合并结果是为空，所以在合并之前需要对 NA 进行预处理，替换或者删除。
df.replace(np.nan, '')
df['parent'] = df['parent2'].apply(str) + '/' + df['parent1'].apply(str)
df['parent'] = df['parent2'].astype('str') + '/' + df['parent1'].astype('str')


# 优先使用下面的方法
# 如果某一列如果为空，另一列不为空，则合并结果是为空，显然这并不是我们想要的结果。
# 除非在合并之前需要对空值进行预处理，提前将 np.nan 替换为 ''。
# 所以一般情况下，应该优先使用 se.str.cat() 方法，可以使用 na_rep='' 参数完美解决问题。
df['date'] = df['year'].str.cat(df['month'], sep='-', na_rep='')


# 如果第一个参数 others=None，会返回一个将整列串起来的字符串，与 str.join() 实现的效果一样。
Series.str.cat(others=None, sep=None, na_rep=None, join='left')
```

## 数据透视表

跟 Excel 的用法差不多。

```python
# df.pivot() 方法是 df.pivot_table() 方法的简化版，只能一维表与二维表之间的转换。
df.pivot(index=None, columns=None, values=None) -> 'DataFrame'

# 数据透视表，与 Excel 中的数据透视表基本一样。
# aggfunc 可以是函数名或包含多个函数的列表，也可以是{'列名': 函数名} 的字典，以对不同的列应用不同的函数。
# 常用函数 np.sum, np.mean, np.count, max, min, np.std, np.var, np.cumsum, np.cumprod
df.pivot_table(values=None,index=None,columns=None,aggfunc='mean',fill_value=None,margins=False,dropna=True,
    margins_name='All',observed=False,) -> 'DataFrame'
# 常用的统计函数包括 max, min, mean, median, std, var, sum, quantile，其中分位数计算是全局方法，因此不能通过 array.quantile 的方法调用
```

参考：<https://blog.csdn.net/CoderPai/article/details/83577805>

<https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html>

除非你有非常具体的要求，否则对自定义功能的需求很小。pandas 中内置的函数已经能基本满足需求了，具体的函数可以[点击这个页面](http://pandas.pydata.org/pandas-docs/stable/basics.html)。

## 分组

```python
df.groupby(by=None, axis=0, level=None, as_index=True, sort=True, group_keys=True, observed=False, dropna=True)
```

## 插列

```python
df.insert(0, '性别', df.pop('gender'))
```

## 长宽表转换

参考：<https://www.cnblogs.com/rachelross/p/10439704.html>

<https://www.cnblogs.com/cycxtz/p/13394583.html>

参考：<https://nikgrozev.com/2015/07/01/reshaping-in-pandas-pivot-pivot-table-stack-and-unstack-explained-with-pictures/>

透视：长表格 转 宽表格，使用 df.pivot() 或 df.pivot_table() 方法。

逆透视：宽表格 转 长表格，使用 df.melt() 方法。

综上，可以总结，stack 的作用就是可以将横向的表头 (列名) 转成纵向的索引列展示，对于多行表头而言，具体要转换哪一行取决于 level 参数，如果不指定，则默认转换最下面一行表头。

In fact pivoting a table is a special case of stacking a DataFrame.

### 逆透视

```python
df
#-----------------------------------------------------------------------------
     年份 其他产值(亿元) 安装工程产值(亿元) 建筑业总产值(亿元) 建筑工程产值(亿元)
0 2000 0.00000     1394.37750 12497.60000         10845.26570
1 2001 0.00000     1764.21800 15361.56000         13285.44250
2 2002 0.00000  2173.50280 18527.18000         15710.31660
... ... ... ...
17 2017 6896.90151 17882.02781     213943.55899 189164.62967
18 2018 7868.91000 19630.16000     225816.86000 207586.45000
19 2019 8428.79969 21353.81595     248443.27073 218660.65509
#-----------------------------------------------------------------------------
# df.melt(id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index=True)
df.melt(id_vars='年份', value_vars=None, var_name='产值', value_name='金额')
#-----------------------------------------------------------------------------
    年份    产值           金额
0 2000 其他产值(亿元) 0.00000
1 2001 其他产值(亿元) 0.00000
2 2002 其他产值(亿元) 0.00000
... ... ... ...
77 2017 建筑工程产值(亿元) 189164.62967
78 2018 建筑工程产值(亿元) 207586.45000
79 2019 建筑工程产值(亿元) 218660.65509
#-----------------------------------------------------------------------------
# df.stack(level=- 1, dropna=True)
df.set_index('年份').stack().reset_index().rename(columns={'level_1':'产值', 0:'金额'})
#-----------------------------------------------------------------------------
    年份    产值             金额
0 2000 其他产值(亿元)   0.00000
1 2001 其他产值(亿元)   0.00000
2 2002 其他产值(亿元)   0.00000
... ... ... ...
77 2017 建筑工程产值(亿元) 189164.62967
78 2018 建筑工程产值(亿元) 207586.45000
79 2019 建筑工程产值(亿元) 218660.65509
#-----------------------------------------------------------------------------
```

### 透视

透视：长表格 转 宽表格，使用 df.pivot() 或 df.pivot_table() 方法。

其实，应用 stack 和 unstack 只需要记住下面的知识点即可：

- stack: 将数据从”表格结构“变成”花括号结构“，即将其列索引变成行索引。
- unstack: 数据从”花括号结构“变成”表格结构“，即要将其中一层的行索引变成列索引。如果是多层索引，则以上函数是针对内层索引（这里是 store）。利用 level 可以选择具体哪层索引。

```python
df
#-----------------------------------------------------------------------------
    年份    产值             金额
0 2000 其他产值(亿元)   0.00000
1 2001 其他产值(亿元)   0.00000
2 2002 其他产值(亿元)   0.00000
... ... ... ...
77 2017 建筑工程产值(亿元) 189164.62967
78 2018 建筑工程产值(亿元) 207586.45000
79 2019 建筑工程产值(亿元) 218660.65509
#-----------------------------------------------------------------------------
# df.pivot(index=None, columns=None, values=None)
df.pivot(index='年份', columns='产值', values='金额')
# 还自动保留了原来的列标签名，作为新的 columns index 的名字。
#-----------------------------------------------------------------------------
     产值 其他产值(亿元) 安装工程产值(亿元) 建筑业总产值(亿元) 建筑工程产值(亿元)
     年份
0 2000 0.00000     1394.37750    12497.60000         10845.26570
1 2001 0.00000     1764.21800    15361.56000         13285.44250
2 2002 0.00000  2173.50280    18527.18000         15710.31660
... ... ... ...
17 2017 6896.90151 17882.02781     213943.55899     189164.62967
18 2018 7868.91000 19630.16000     225816.86000     207586.45000
19 2019 8428.79969 21353.81595     248443.27073     218660.65509
#-----------------------------------------------------------------------------
# 因为 stack 与 unstack 是处理索引，所以一定要先设置索引。
df.set_index(['年份', '产值']).unstack().reset_index()
# 返回多重索引行，需要删除第一个索引‘金额’
# df.set_index(['年份', '产值']).unstack().droplevel(0, axis=1).reset_index()
#-----------------------------------------------------------------------------
 年份 金额
产值  其他产值(亿元) 安装工程产值(亿元) 建筑业总产值(亿元) 建筑工程产值(亿元)
0 2000 0.00000     1394.37750    12497.60000         10845.26570
1 2001 0.00000     1764.21800    15361.56000         13285.44250
2 2002 0.00000  2173.50280    18527.18000         15710.31660
... ... ... ...
17 2017 6896.90151 17882.02781     213943.55899     189164.62967
18 2018 7868.91000 19630.16000     225816.86000     207586.45000
19 2019 8428.79969 21353.81595     248443.27073     218660.65509
#-----------------------------------------------------------------------------
df.set_index(['年份', '产值']).unstack().droplevel(0, axis=1).reset_index()
#-----------------------------------------------------------------------------
产值 年份 其他产值(亿元) 安装工程产值(亿元) 建筑业总产值(亿元) 建筑工程产值(亿元)
0 2000 0.00000     1394.37750    12497.60000         10845.26570
1 2001 0.00000     1764.21800    15361.56000         13285.44250
2 2002 0.00000  2173.50280    18527.18000         15710.31660
... ... ... ...
17 2017 6896.90151 17882.02781     213943.55899     189164.62967
18 2018 7868.91000 19630.16000     225816.86000     207586.45000
19 2019 8428.79969 21353.81595     248443.27073     218660.65509
#-----------------------------------------------------------------------------
```

### 透视表
