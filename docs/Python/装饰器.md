## 类的装饰器

包装一个类

```python
def decorator(cls):
    """ 类装饰器
    先构建一个子类，再复制所有的属性和方法，然后覆盖修改其中的某个属性或方法。
    使用方法：
        requests.Session = decorator(requests.Session)
    相当于 用修改后的类替换了真正的类。
    可以实现在不修改源码的情况下，对某个类进行修改，如果要修改某个方法或函数，方法一样。
    如果修改的东西多，可以考虑创建一个模块，定义个装饰器类，供其它的程序调用。

    :param cls: 传入参数为一个类 class
    :return: 返回修改后的类 class
    """
    class Wrapper(cls):
        def __init__(self):
            # super() 函数用来调用父类的方法，与 super(Wrapper, self).__init__() 相同
            super().__init__()
            head = {
                'User-Agent': r'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'zh-CN,zh;q=0.9',
                'Cache-Control': 'max-age=0',
                'Upgrade-Insecure-Requests': '1',
                'DNT': '1',
                'Connection': 'keep-alive'
            }
            self.headers.update(head)
    return Wrapper
```
